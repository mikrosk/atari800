Address Modes:

A		....	Accumulator	 	OPC A	 	operand is AC
abs		....	absolute	 	OPC $HHLL	 	operand is address $HHLL
abs,X		....	absolute, X-indexed	 	OPC $HHLL,X	 	operand is address incremented by X with carry
abs,Y		....	absolute, Y-indexed	 	OPC $HHLL,Y	 	operand is address incremented by Y with carry
#		....	immediate	 	OPC #$BB	 	operand is byte (BB)
impl		....	implied	 	OPC	 	operand implied
ind		....	indirect	 	OPC ($HHLL)	 	operand is effective address; effective address is value of address
X,ind		....	X-indexed, indirect	 	OPC ($BB,X)	 	operand is effective zeropage address; effective address is byte (BB) incremented by X without carry
ind,Y		....	indirect, Y-indexed	 	OPC ($LL),Y	 	operand is effective address incremented by Y with carry; effective address is word at zeropage address
rel		....	relative	 	OPC $BB	 	branch target is PC + offset (BB), bit 7 signifies negative offset
zpg		....	zeropage	 	OPC $LL	 	operand is of address; address hibyte = zero ($00xx)
zpg,X		....	zeropage, X-indexed	 	OPC $LL,X	 	operand is address incremented by X; address hibyte = zero ($00xx); no page transition
zpg,Y		....	zeropage, Y-indexed	 	OPC $LL,Y	 	operand is address incremented by Y; address hibyte = zero ($00xx); no page transition


Instructions by Name:

ADC	....	add with carry
AND	....	and (with accumulator)
ASL	....	arithmetic shift left
BCC	....	branch on carry clear
BCS	....	branch on carry set
BEQ	....	branch on equal (zero set)
BIT	....	bit test
BMI	....	branch on minus (negative set)
BNE	....	branch on not equal (zero clear)
BPL	....	branch on plus (negative clear)
BRK	....	interrupt
BVC	....	branch on overflow clear
BVS	....	branch on overflow set
CLC	....	clear carry
CLD	....	clear decimal
CLI	....	clear interrupt disable
CLV	....	clear overflow
CMP	....	compare (with accumulator)
CPX	....	compare with X
CPY	....	compare with Y
DEC	....	decrement
DEX	....	decrement X
DEY	....	decrement Y
EOR	....	exclusive or (with accumulator)
INC	....	increment
INX	....	increment X
INY	....	increment Y
JMP	....	jump
JSR	....	jump subroutine
LDA	....	load accumulator
LDX	....	load X
LDY	....	load Y
LSR	....	logical shift right
NOP	....	no operation
ORA	....	or with accumulator
PHA	....	push accumulator
PHP	....	push processor status (SR)
PLA	....	pull accumulator
PLP	....	pull processor status (SR)
ROL	....	rotate left
ROR	....	rotate right
RTI	....	return from interrupt
RTS	....	return from subroutine
SBC	....	subtract with carry
SEC	....	set carry
SED	....	set decimal
SEI	....	set interrupt disable
STA	....	store accumulator
STX	....	store X
STY	....	store Y
TAX	....	transfer accumulator to X
TAY	....	transfer accumulator to Y
TSX	....	transfer stack pointer to X
TXA	....	transfer X to accumulator
TXS	....	transfer X to stack pointer
TYA	....	transfer Y to accumulator


Registers:

PC	....	program counter	(16 bit)
AC	....	accumulator	(8 bit)
X	....	X register	(8 bit)
Y	....	Y register	(8 bit)
SR	....	status register [NV-BDIZC]	(8 bit)
SP	....	stack pointer	(8 bit)

SR Flags (bit 7 to bit 0):

N	....	Negative
V	....	Overflow
-	....	ignored
B	....	Break
D	....	Decimal (use BCD for arithmetics)
I	....	Interrupt (IRQ disable)
Z	....	Zero
C	....	Carry


Processor Stack:
LIFO, top down, 8 bit range, 0x0100 - 0x01FF


Bytes, Words, Addressing:
8 bit bytes, 16 bit words in lobyte-hibyte representation (Little-Endian).
16 bit address range, operands follow instruction codes.


Vendor:
MOS Technology, 1975

MOS Techology 6502 MPU


APPENDIX A: 6502 Instructions in Detail

instrukcii: 55
acc pouziva: 19
x pouziva: 9
y pouziva: 7
pc (kazda) + 13
sp: 10
sr..

d0.b: acc
d1.w: pc
a0.w: sp (realna adresa, zarovnana na 64k) ... nemoze byt a7, pretoze vyzaduje vzdy even adresy :-(
a1.l: memory
---------
d2.b: x
d3.b: y
sr: register? zvlast bunky?

#define PL                  MEMORY_dGetByte(0x0100 + ++S)
#define PH(x)               MEMORY_dPutByte(0x0100 + S--, x)
#define PHW(x)              PH((x) >> 8); PH((x) & 0xff)

/* 6502 code fetching */
#define GET_PC()            PC
#define SET_PC(newpc)       (PC = (newpc))
#define PHPC                PHW(PC)
#define GET_CODE_BYTE()     MEMORY_dGetByte(PC++)
#define PEEK_CODE_BYTE()    MEMORY_dGetByte(PC)
#define PEEK_CODE_WORD()    MEMORY_dGetWord(PC)

#define OP_BYTE     PEEK_CODE_BYTE()
#define OP_WORD     PEEK_CODE_WORD()
#define IMMEDIATE   GET_CODE_BYTE()
#define ABSOLUTE    addr = PEEK_CODE_WORD(); PC += 2
#define ZPAGE       addr = GET_CODE_BYTE()
#define ABSOLUTE_X  addr = PEEK_CODE_WORD() + X; PC += 2
#define ABSOLUTE_Y  addr = PEEK_CODE_WORD() + Y; PC += 2
#define INDIRECT_X  addr = (UBYTE) (GET_CODE_BYTE() + X); addr = zGetWord(addr)
#define INDIRECT_Y  addr = GET_CODE_BYTE(); addr = zGetWord(addr) + Y
#define ZPAGE_X     addr = (UBYTE) (GET_CODE_BYTE() + X)
#define ZPAGE_Y     addr = (UBYTE) (GET_CODE_BYTE() + Y)

UWORD CPU_regPC;
UBYTE CPU_regA;
UBYTE CPU_regX;
UBYTE CPU_regY;
UBYTE CPU_regP;						/* Processor Status Byte (Partial) */
UBYTE CPU_regS;
UBYTE CPU_IRQ;

static UBYTE N;					/* bit7 set => N flag set */
static UBYTE V;                 /* non-zero => V flag set */
static UBYTE Z;					/* zero     => Z flag set */
static UBYTE C;					/* must be 0 or 1 */
/* B, D, I are always in CPU_regP */

CPU_regP = (N & 0x80) + (V ? 0x40 : 0) + (CPU_regP & 0x3c) + ((Z == 0) ? 0x02 : 0) + C;

; Bit    : 76543210
; 68000  : ***XNZVC
; _RegP  : NV*BDIZC

#define AND(t_data) Z = N = A &= t_data
#define CMP(t_data) data = t_data; Z = N = A - data; C = (A >= data)
#define CPX(t_data) data = t_data; Z = N = X - data; C = (X >= data)
#define CPY(t_data) data = t_data; Z = N = Y - data; C = (Y >= data)
#define EOR(t_data) Z = N = A ^= t_data
#define LDA(t_data) Z = N = A = t_data
#define LDX(t_data) Z = N = X = t_data
#define LDY(t_data) Z = N = Y = t_data
#define ORA(t_data) Z = N = A |= t_data
#define PHP(x)      data = (N & 0x80) + (V ? 0x40 : 0) + (CPU_regP & (x)) + ((Z == 0) ? 0x02 : 0) + C; PH(data) // toto priamo nepouzivame nikde)
#define PHPB0       PHP(0x2c)  /* push flags with B flag clear (NMI, IRQ) */
#define PHPB1       PHP(0x3c)  /* push flags with B flag set (PHP, BRK) */
#define PLP         data = PL; N = data; V = (data & 0x40); Z = (data & 0x02) ^ 0x02; C = (data & 0x01); CPU_regP = (data & 0x0c) + 0x30

m68k:
add
X — Set the same as the carry bit.
N — Set if the result is negative; cleared otherwise.
Z — Set if the result is zero; cleared otherwise.
V — Set if an overflow is generated; cleared otherwise.
C — Set if a carry is generated; cleared otherwise.
and
X — Not affected.
N — Set if the most significant bit of the result is set; cleared otherwise.
Z — Set if the result is zero; cleared otherwise.
V — Always cleared.
C — Always cleared.
cmp
X — Not affected.
N — Set if the result is negative; cleared otherwise.
Z — Set if the result is zero; cleared otherwise.
V — Set if an overflow occurs; cleared otherwise.
C — Set if a borrow occurs; cleared otherwise.
eor
X — Not affected.
N — Set if the most significant bit of the result is set; cleared otherwise.
Z — Set if the result is zero; cleared otherwise.
V — Always cleared.
C — Always cleared.
move
X — Not affected.
N — Set if the result is negative; cleared otherwise.
Z — Set if the result is zero; cleared otherwise.
V — Always cleared.
C — Always cleared.
or
X — Not affected.
N — Set if the most significant bit of the result is set; cleared otherwise.
Z — Set if the result is zero; cleared otherwise.
V — Always cleared.
C — Always cleared.
rol, ror
X — Not affected.
N — Set if the most significant bit of the result is set; cleared otherwise.
Z — Set if the result is zero; cleared otherwise.
V — Always cleared.
C — Set according to the last bit rotated out of the operand; cleared when the rotate count is zero.

/* ---------------------------------------------- */
/* ADC and SBC routines */

	adc:
		if (!(CPU_regP & CPU_D_FLAG)) {
			/* Binary mode */
			unsigned int tmp;
			tmp = A + data + C;
			C = tmp > 0xff;
			/* C = tmp >> 8; */
			V = !((A ^ data) & 0x80) && ((data ^ tmp) & 0x80);
			Z = N = A = (UBYTE) tmp;
	    }
		else {
			/* Decimal mode */
			unsigned int tmp;
			tmp = (A & 0x0f) + (data & 0x0f) + C;
			if (tmp >= 10)
				tmp = (tmp - 10) | 0x10;
			tmp += (A & 0xf0) + (data & 0xf0);

			Z = A + data + C;
			N = (UBYTE) tmp;
			V = !((A ^ data) & 0x80) && ((data ^ tmp) & 0x80);

			if (tmp > 0x9f)
				tmp += 0x60;
			C = tmp > 0xff;
			A = (UBYTE) tmp;
		}
		DONE

	sbc:
		if (!(CPU_regP & CPU_D_FLAG)) {
			/* Binary mode */
			unsigned int tmp;
			/* tmp = A - data - !C; */
			tmp = A - data - 1 + C;
			C = tmp < 0x100;
			V = ((A ^ tmp) & 0x80) && ((A ^ data) & 0x80);
			Z = N = A = (UBYTE) tmp;
		}
		else {
			/* Decimal mode */
			unsigned int al, ah, tmp;
			/* tmp = A - data - !C; */
			tmp = A - data - 1 + C;
			/* al = (A & 0x0f) - (data & 0x0f) - !C; */
			al = (A & 0x0f) - (data & 0x0f) - 1 + C;	/* Calculate lower nybble */
			ah = (A >> 4) - (data >> 4);		/* Calculate upper nybble */
			if (al & 0x10) {
				al -= 6;	/* BCD fixup for lower nybble */
				ah--;
			}
			if (ah & 0x10)
				ah -= 6;	/* BCD fixup for upper nybble */

			C = tmp < 0x100;			/* Set flags */
			V = ((A ^ tmp) & 0x80) && ((A ^ data) & 0x80);
			Z = N = (UBYTE) tmp;

			A = (ah << 4) + (al & 0x0f);	/* Compose result */
		}
		DONE

ADC  Add Memory to Accumulator with Carry

     A + M + C -> A, C                N Z C I D V
                                      + + + - - +

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     immidiate     ADC #oper     69    2     2
     zeropage      ADC oper      65    2     3
     zeropage,X    ADC oper,X    75    2     4
     absolute      ADC oper      6D    3     4
     absolute,X    ADC oper,X    7D    3     4*
     absolute,Y    ADC oper,Y    79    3     4*
     (indirect,X)  ADC (oper,X)  61    2     6
     (indirect),Y  ADC (oper),Y  71    2     5*


AND  AND Memory with Accumulator

     A AND M -> A                     N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     immidiate     AND #oper     29    2     2
     zeropage      AND oper      25    2     3
     zeropage,X    AND oper,X    35    2     4
     absolute      AND oper      2D    3     4
     absolute,X    AND oper,X    3D    3     4*
     absolute,Y    AND oper,Y    39    3     4*
     (indirect,X)  AND (oper,X)  21    2     6
     (indirect),Y  AND (oper),Y  31    2     5*


ASL  Shift Left One Bit (Memory or Accumulator)

     C <- [76543210] <- 0             N Z C I D V
                                      + + + - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     accumulator   ASL A         0A    1     2
     zeropage      ASL oper      06    2     5
     zeropage,X    ASL oper,X    16    2     6
     absolute      ASL oper      0E    3     6
     absolute,X    ASL oper,X    1E    3     7


BCC  Branch on Carry Clear

     branch on C = 0                  N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     relative      BCC oper      90    2     2**


BCS  Branch on Carry Set

     branch on C = 1                  N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     relative      BCS oper      B0    2     2**


BEQ  Branch on Result Zero

     branch on Z = 1                  N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     relative      BEQ oper      F0    2     2**


BIT  Test Bits in Memory with Accumulator

     bits 7 and 6 of operand are transfered to bit 7 and 6 of SR (N,V);
     the zeroflag is set to the result of operand AND accumulator.

     A AND M, M7 -> N, M6 -> V        N Z C I D V
                                     M7 + - - - M6

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     zeropage      BIT oper      24    2     3
     absolute      BIT oper      2C    3     4


BMI  Branch on Result Minus

     branch on N = 1                  N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     relative      BMI oper      30    2     2**


BNE  Branch on Result not Zero

     branch on Z = 0                  N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     relative      BNE oper      D0    2     2**


BPL  Branch on Result Plus

     branch on N = 0                  N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     relative      BPL oper      10    2     2**


BRK  Force Break

     interrupt,                       N Z C I D V
     push PC+2, push SR               - - - 1 - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       BRK           00    1     7


BVC  Branch on Overflow Clear

     branch on V = 0                  N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     relative      BVC oper      50    2     2**


BVS  Branch on Overflow Set

     branch on V = 1                  N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     relative      BVC oper      70    2     2**


CLC  Clear Carry Flag

     0 -> C                           N Z C I D V
                                      - - 0 - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       CLC           18    1     2


CLD  Clear Decimal Mode

     0 -> D                           N Z C I D V
                                      - - - - 0 -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       CLD           D8    1     2


CLI  Clear Interrupt Disable Bit

     0 -> I                           N Z C I D V
                                      - - - 0 - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       CLI           58    1     2


CLV  Clear Overflow Flag

     0 -> V                           N Z C I D V
                                      - - - - - 0

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       CLV           B8    1     2


CMP  Compare Memory with Accumulator

     A - M                            N Z C I D V
                                      + + + - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     immidiate     CMP #oper     C9    2     2
     zeropage      CMP oper      C5    2     3
     zeropage,X    CMP oper,X    D5    2     4
     absolute      CMP oper      CD    3     4
     absolute,X    CMP oper,X    DD    3     4*
     absolute,Y    CMP oper,Y    D9    3     4*
     (indirect,X)  CMP (oper,X)  C1    2     6
     (indirect),Y  CMP (oper),Y  D1    2     5*


CPX  Compare Memory and Index X

     X - M                            N Z C I D V
                                      + + + - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     immidiate     CPX #oper     E0    2     2
     zeropage      CPX oper      E4    2     3
     absolute      CPX oper      EC    3     4


CPY  Compare Memory and Index Y

     Y - M                            N Z C I D V
                                      + + + - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     immidiate     CPY #oper     C0    2     2
     zeropage      CPY oper      C4    2     3
     absolute      CPY oper      CC    3     4


DEC  Decrement Memory by One

     M - 1 -> M                       N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     zeropage      DEC oper      C6    2     5
     zeropage,X    DEC oper,X    D6    2     6
     absolute      DEC oper      CE    3     3
     absolute,X    DEC oper,X    DE    3     7


DEX  Decrement Index X by One

     X - 1 -> X                       N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       DEC           CA    1     2


DEY  Decrement Index Y by One

     Y - 1 -> Y                       N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       DEC           88    1     2


EOR  Exclusive-OR Memory with Accumulator

     A EOR M -> A                     N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     immidiate     EOR #oper     49    2     2
     zeropage      EOR oper      45    2     3
     zeropage,X    EOR oper,X    55    2     4
     absolute      EOR oper      4D    3     4
     absolute,X    EOR oper,X    5D    3     4*
     absolute,Y    EOR oper,Y    59    3     4*
     (indirect,X)  EOR (oper,X)  41    2     6
     (indirect),Y  EOR (oper),Y  51    2     5*


INC  Increment Memory by One

     M + 1 -> M                       N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     zeropage      INC oper      E6    2     5
     zeropage,X    INC oper,X    F6    2     6
     absolute      INC oper      EE    3     6
     absolute,X    INC oper,X    FE    3     7


INX  Increment Index X by One

     X + 1 -> X                       N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       INX           E8    1     2


INY  Increment Index Y by One

     Y + 1 -> Y                       N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       INY           C8    1     2


JMP  Jump to New Location

     (PC+1) -> PCL                    N Z C I D V
     (PC+2) -> PCH                    - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     absolute      JMP oper      4C    3     3
     indirect      JMP (oper)    6C    3     5


JSR  Jump to New Location Saving Return Address

     push (PC+2),                     N Z C I D V
     (PC+1) -> PCL                    - - - - - -
     (PC+2) -> PCH

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     absolute      JSR oper      20    3     6


LDA  Load Accumulator with Memory

     M -> A                           N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     immidiate     LDA #oper     A9    2     2
     zeropage      LDA oper      A5    2     3
     zeropage,X    LDA oper,X    B5    2     4
     absolute      LDA oper      AD    3     4
     absolute,X    LDA oper,X    BD    3     4*
     absolute,Y    LDA oper,Y    B9    3     4*
     (indirect,X)  LDA (oper,X)  A1    2     6
     (indirect),Y  LDA (oper),Y  B1    2     5*


LDX  Load Index X with Memory

     M -> X                           N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     immidiate     LDX #oper     A2    2     2
     zeropage      LDX oper      A6    2     3
     zeropage,Y    LDX oper,Y    B6    2     4
     absolute      LDX oper      AE    3     4
     absolute,Y    LDX oper,Y    BE    3     4*


LDY  Load Index Y with Memory

     M -> Y                           N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     immidiate     LDY #oper     A0    2     2
     zeropage      LDY oper      A4    2     3
     zeropage,X    LDY oper,X    B4    2     4
     absolute      LDY oper      AC    3     4
     absolute,X    LDY oper,X    BC    3     4*


LSR  Shift One Bit Right (Memory or Accumulator)

     0 -> [76543210] -> C             N Z C I D V
                                      - + + - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     accumulator   LSR A         4A    1     2
     zeropage      LSR oper      46    2     5
     zeropage,X    LSR oper,X    56    2     6
     absolute      LSR oper      4E    3     6
     absolute,X    LSR oper,X    5E    3     7


NOP  No Operation

     ---                              N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       NOP           EA    1     2


ORA  OR Memory with Accumulator

     A OR M -> A                      N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     immidiate     ORA #oper     09    2     2
     zeropage      ORA oper      05    2     3
     zeropage,X    ORA oper,X    15    2     4
     absolute      ORA oper      0D    3     4
     absolute,X    ORA oper,X    1D    3     4*
     absolute,Y    ORA oper,Y    19    3     4*
     (indirect,X)  ORA (oper,X)  01    2     6
     (indirect),Y  ORA (oper),Y  11    2     5*


PHA  Push Accumulator on Stack

     push A                           N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       PHA           48    1     3


PHP  Push Processor Status on Stack

     push SR                          N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       PHP           08    1     3


PLA  Pull Accumulator from Stack

     pull A                           N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       PLA           68    1     4


PLP  Pull Processor Status from Stack

     pull SR                          N Z C I D V
                                      from stack

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       PHP           28    1     4


ROL  Rotate One Bit Left (Memory or Accumulator)

     C <- [76543210] <- C             N Z C I D V
                                      + + + - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     accumulator   ROL A         2A    1     2
     zeropage      ROL oper      26    2     5
     zeropage,X    ROL oper,X    36    2     6
     absolute      ROL oper      2E    3     6
     absolute,X    ROL oper,X    3E    3     7


ROR  Rotate One Bit Right (Memory or Accumulator)

     C -> [76543210] -> C             N Z C I D V
                                      + + + - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     accumulator   ROR A         6A    1     2
     zeropage      ROR oper      66    2     5
     zeropage,X    ROR oper,X    76    2     6
     absolute      ROR oper      6E    3     6
     absolute,X    ROR oper,X    7E    3     7


RTI  Return from Interrupt

     pull SR, pull PC                 N Z C I D V
                                      from stack

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       RTI           40    1     6


RTS  Return from Subroutine

     pull PC, PC+1 -> PC              N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       RTS           60    1     6


SBC  Subtract Memory from Accumulator with Borrow

     A - M - C -> A                   N Z C I D V
                                      + + + - - +

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     immidiate     SBC #oper     E9    2     2
     zeropage      SBC oper      E5    2     3
     zeropage,X    SBC oper,X    F5    2     4
     absolute      SBC oper      ED    3     4
     absolute,X    SBC oper,X    FD    3     4*
     absolute,Y    SBC oper,Y    F9    3     4*
     (indirect,X)  SBC (oper,X)  E1    2     6
     (indirect),Y  SBC (oper),Y  F1    2     5*


SEC  Set Carry Flag

     1 -> C                           N Z C I D V
                                      - - 1 - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       SEC           38    1     2


SED  Set Decimal Flag

     1 -> D                           N Z C I D V
                                      - - - - 1 -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       SED           F8    1     2


SEI  Set Interrupt Disable Status

     1 -> I                           N Z C I D V
                                      - - - 1 - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       SEI           78    1     2


STA  Store Accumulator in Memory

     A -> M                           N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     zeropage      STA oper      85    2     3
     zeropage,X    STA oper,X    95    2     4
     absolute      STA oper      8D    3     4
     absolute,X    STA oper,X    9D    3     5
     absolute,Y    STA oper,Y    99    3     5
     (indirect,X)  STA (oper,X)  81    2     6
     (indirect),Y  STA (oper),Y  91    2     6


STX  Store Index X in Memory

     X -> M                           N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     zeropage      STX oper      86    2     3
     zeropage,Y    STX oper,Y    96    2     4
     absolute      STX oper      8E    3     4


STY  Sore Index Y in Memory

     Y -> M                           N Z C I D V
                                      - - - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     zeropage      STY oper      84    2     3
     zeropage,X    STY oper,X    94    2     4
     absolute      STY oper      8C    3     4


TAX  Transfer Accumulator to Index X

     A -> X                           N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       TAX           AA    1     2


TAY  Transfer Accumulator to Index Y

     A -> Y                           N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       TAY           A8    1     2


TSX  Transfer Stack Pointer to Index X

     SP -> X                          N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       TSX           BA    1     2


TXA  Transfer Index X to Accumulator

     X -> A                           N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       TXA           8A    1     2


TXS  Transfer Index X to Stack Register

     X -> SP                          N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       TXS           9A    1     2


TYA  Transfer Index Y to Accumulator

     Y -> A                           N Z C I D V
                                      + + - - - -

     addressing    assembler    opc  bytes  cyles
     --------------------------------------------
     implied       TYA           98    1     2



  *  add 1 to cycles if page boundery is crossed

  ** add 1 to cycles if branch occurs on same page
     add 2 to cycles if branch occurs to different page


     Legend to Flags:  + .... modified
                       - .... not modified
                       1 .... set
                       0 .... cleared
                      M6 .... memory bit 6
                      M7 .... memory bit 7


Note on assembler syntax:
Most assemblers employ "OPC *oper" for forced zeropage addressing.



APENDIX B: The 65xx-Family:

  Type               Features, Comments
  -------------------------------------
  6502               NMOS, 16 bit address bus, 8 bit data bus
  6502A              accelerated version of 6502
  6502C              accelerated version of 6502, CMOS
  65C02              16 bit version, additional instructions and address modes
  6503, 6505, 6506   12 bit address bus [4 KiB]
  6504               13 bit address bus [8 KiB]
  6507               13 bit address bus [8 KiB], no interrupts
  6509               20 bit address bus [1 MiB] by bankswitching
  6510               as 6502 with additional 6 bit I/O-port
  6511               integrated micro controler with I/O-port, serial interface, and RAM (Rockwell)
  65F11              as 6511, integrated FORTH interpreter
  7501               as 6502, HMOS
  8500               as 6510, CMOS
  8502               as 6510 with switchable 2 MHz option, 7 bit I/O-port
  65816 (65C816)     16 bit registers and ALU, 24 bit address bus [16 MiB], up to 24 MHz (Western Design Center)
  65802 (65C802)     as 65816, pin compatible to 6502, 64 KiB address bus, up to 16 MHz

  	OPCODE(00)				/* BRK */
	OPCODE(01)				/* ORA (ab,x) */
	OPCODE(03)				/* ASO (ab,x) [unofficial - ASL then ORA with Acc] */

	OPCODE_ALIAS(04)		/* NOP ab [unofficial - skip byte] */
	OPCODE_ALIAS(44)
	OPCODE(64)

	OPCODE_ALIAS(14)		/* NOP ab,x [unofficial - skip byte] */
	OPCODE_ALIAS(34)
	OPCODE_ALIAS(54)
	OPCODE_ALIAS(74)
	OPCODE_ALIAS(d4)
	OPCODE(f4)

	OPCODE_ALIAS(80)		/* NOP #ab [unofficial - skip byte] */
	OPCODE_ALIAS(82)
	OPCODE_ALIAS(89)
	OPCODE_ALIAS(c2)
	OPCODE(e2)

	OPCODE(05)				/* ORA ab */
	OPCODE(06)				/* ASL ab */
	OPCODE(07)				/* ASO ab [unofficial - ASL then ORA with Acc] */
	OPCODE(08)				/* PHP */
	OPCODE(09)				/* ORA #ab */
	OPCODE(0a)				/* ASL */

	OPCODE_ALIAS(0b)		/* ANC #ab [unofficial - AND then copy N to C (Fox) */
	OPCODE(2b)

	OPCODE(0c)				/* NOP abcd [unofficial - skip word] */
	OPCODE(0d)				/* ORA abcd */
	OPCODE(0e)				/* ASL abcd */
	OPCODE(0f)				/* ASO abcd [unofficial - ASL then ORA with Acc] */
	OPCODE(10)				/* BPL */
	OPCODE(11)				/* ORA (ab),y */
	OPCODE(13)				/* ASO (ab),y [unofficial - ASL then ORA with Acc] */
	OPCODE(15)				/* ORA ab,x */
	OPCODE(16)				/* ASL ab,x */
	OPCODE(17)				/* ASO ab,x [unofficial - ASL then ORA with Acc] */
	OPCODE(18)				/* CLC */
	OPCODE(19)				/* ORA abcd,y */
	OPCODE(1b)				/* ASO abcd,y [unofficial - ASL then ORA with Acc] */

	OPCODE_ALIAS(1c)		/* NOP abcd,x [unofficial - skip word] */
	OPCODE_ALIAS(3c)
	OPCODE_ALIAS(5c)
	OPCODE_ALIAS(7c)
	OPCODE_ALIAS(dc)
	OPCODE(fc)

	OPCODE(1d)				/* ORA abcd,x */
	OPCODE(1e)				/* ASL abcd,x */
	OPCODE(1f)				/* ASO abcd,x [unofficial - ASL then ORA with Acc] */
	OPCODE(20)				/* JSR abcd */
	OPCODE(21)				/* AND (ab,x) */
	OPCODE(23)				/* RLA (ab,x) [unofficial - ROL Mem, then AND with A] */
	OPCODE(24)				/* BIT ab */
	OPCODE(25)				/* AND ab */
	OPCODE(26)				/* ROL ab */
	OPCODE(27)				/* RLA ab [unofficial - ROL Mem, then AND with A] */
	OPCODE(28)				/* PLP */
	OPCODE(29)				/* AND #ab */
	OPCODE(2a)				/* ROL */
	OPCODE(2c)				/* BIT abcd */
	OPCODE(2d)				/* AND abcd */
	OPCODE(2e)				/* ROL abcd */
	OPCODE(2f)				/* RLA abcd [unofficial - ROL Mem, then AND with A] */
	OPCODE(30)				/* BMI */
	OPCODE(31)				/* AND (ab),y */
	OPCODE(33)				/* RLA (ab),y [unofficial - ROL Mem, then AND with A] */
	OPCODE(35)				/* AND ab,x */
	OPCODE(36)				/* ROL ab,x */
	OPCODE(37)				/* RLA ab,x [unofficial - ROL Mem, then AND with A] */
	OPCODE(38)				/* SEC */
	OPCODE(39)				/* AND abcd,y */
	OPCODE(3b)				/* RLA abcd,y [unofficial - ROL Mem, then AND with A] */
	OPCODE(3d)				/* AND abcd,x */
	OPCODE(3e)				/* ROL abcd,x */
	OPCODE(3f)				/* RLA abcd,x [unofficial - ROL Mem, then AND with A] */
	OPCODE(40)				/* RTI */
	OPCODE(41)				/* EOR (ab,x) */
	OPCODE(43)				/* LSE (ab,x) [unofficial - LSR then EOR result with A] */
	OPCODE(45)				/* EOR ab */
	OPCODE(46)				/* LSR ab */
	OPCODE(47)				/* LSE ab [unofficial - LSR then EOR result with A] */
	OPCODE(48)				/* PHA */
	OPCODE(49)				/* EOR #ab */
	OPCODE(4a)				/* LSR */
	OPCODE(4b)				/* ALR #ab [unofficial - Acc AND Data, LSR result] */
	OPCODE(4c)				/* JMP abcd */
	OPCODE(4d)				/* EOR abcd */
	OPCODE(4e)				/* LSR abcd */
	OPCODE(4f)				/* LSE abcd [unofficial - LSR then EOR result with A] */
	OPCODE(50)				/* BVC */
	OPCODE(51)				/* EOR (ab),y */
	OPCODE(53)				/* LSE (ab),y [unofficial - LSR then EOR result with A] */
	OPCODE(55)				/* EOR ab,x */
	OPCODE(56)				/* LSR ab,x */
	OPCODE(57)				/* LSE ab,x [unofficial - LSR then EOR result with A] */
	OPCODE(58)				/* CLI */
	OPCODE(59)				/* EOR abcd,y */
	OPCODE(5b)				/* LSE abcd,y [unofficial - LSR then EOR result with A] */
	OPCODE(5d)				/* EOR abcd,x */
	OPCODE(5e)				/* LSR abcd,x */
	OPCODE(5f)				/* LSE abcd,x [unofficial - LSR then EOR result with A] */
	OPCODE(60)				/* RTS */
	OPCODE(61)				/* ADC (ab,x) */
	OPCODE(63)				/* RRA (ab,x) [unofficial - ROR Mem, then ADC to Acc] */
	OPCODE(65)				/* ADC ab */
	OPCODE(66)				/* ROR ab */
	OPCODE(67)				/* RRA ab [unofficial - ROR Mem, then ADC to Acc] */
	OPCODE(68)				/* PLA */
	OPCODE(69)				/* ADC #ab */
	OPCODE(6a)				/* ROR */
	OPCODE(6b)				/* ARR #ab [unofficial - Acc AND Data, ROR result] */
	OPCODE(6c)				/* JMP (abcd) */
	OPCODE(6d)				/* ADC abcd */
	OPCODE(6e)				/* ROR abcd */
	OPCODE(6f)				/* RRA abcd [unofficial - ROR Mem, then ADC to Acc] */
	OPCODE(70)				/* BVS */
	OPCODE(71)				/* ADC (ab),y */
	OPCODE(73)				/* RRA (ab),y [unofficial - ROR Mem, then ADC to Acc] */
	OPCODE(75)				/* ADC ab,x */
	OPCODE(76)				/* ROR ab,x */
	OPCODE(77)				/* RRA ab,x [unofficial - ROR Mem, then ADC to Acc] */
	OPCODE(78)				/* SEI */
	OPCODE(79)				/* ADC abcd,y */
	OPCODE(7b)				/* RRA abcd,y [unofficial - ROR Mem, then ADC to Acc] */
	OPCODE(7d)				/* ADC abcd,x */
	OPCODE(7e)				/* ROR abcd,x */
	OPCODE(7f)				/* RRA abcd,x [unofficial - ROR Mem, then ADC to Acc] */
	OPCODE(81)				/* STA (ab,x) */
	OPCODE(83)				/* SAX (ab,x) [unofficial - Store result A AND X */
	OPCODE(84)				/* STY ab */
	OPCODE(85)				/* STA ab */
	OPCODE(86)				/* STX ab */
	OPCODE(87)				/* SAX ab [unofficial - Store result A AND X] */
	OPCODE(88)				/* DEY */
	OPCODE(8a)				/* TXA */
	OPCODE(8b)				/* ANE #ab [unofficial - A AND X AND (Mem OR $EF) to Acc] (Fox) */
	OPCODE(8c)				/* STY abcd */
	OPCODE(8d)				/* STA abcd */
	OPCODE(8e)				/* STX abcd */
	OPCODE(8f)				/* SAX abcd [unofficial - Store result A AND X] */
	OPCODE(90)				/* BCC */
	OPCODE(91)				/* STA (ab),y */
	OPCODE(93)				/* SHA (ab),y [unofficial, UNSTABLE - Store A AND X AND (H+1) ?] (Fox) */
	OPCODE(94)				/* STY ab,x */
	OPCODE(95)				/* STA ab,x */
	OPCODE(96)				/* STX ab,y */
	OPCODE(97)				/* SAX ab,y [unofficial - Store result A AND X] */
	OPCODE(98)				/* TYA */
	OPCODE(99)				/* STA abcd,y */
	OPCODE(9a)				/* TXS */
	OPCODE(9b)				/* SHS abcd,y [unofficial, UNSTABLE] (Fox) */
	OPCODE(9c)				/* SHY abcd,x [unofficial - Store Y and (H+1)] (Fox) */
	OPCODE(9d)				/* STA abcd,x */
	OPCODE(9e)				/* SHX abcd,y [unofficial - Store X and (H+1)] (Fox) */
	OPCODE(9f)				/* SHA abcd,y [unofficial, UNSTABLE - Store A AND X AND (H+1) ?] (Fox) */
	OPCODE(a0)				/* LDY #ab */
	OPCODE(a1)				/* LDA (ab,x) */
	OPCODE(a2)				/* LDX #ab */
	OPCODE(a3)				/* LAX (ab,x) [unofficial] */
	OPCODE(a4)				/* LDY ab */
	OPCODE(a5)				/* LDA ab */
	OPCODE(a6)				/* LDX ab */
	OPCODE(a7)				/* LAX ab [unofficial] */
	OPCODE(a8)				/* TAY */
	OPCODE(a9)				/* LDA #ab */
	OPCODE(aa)				/* TAX */
	OPCODE(ab)				/* ANX #ab [unofficial - AND #ab, then TAX] */
	OPCODE(ac)				/* LDY abcd */
	OPCODE(ad)				/* LDA abcd */
	OPCODE(ae)				/* LDX abcd */
	OPCODE(af)				/* LAX abcd [unofficial] */
	OPCODE(b0)				/* BCS */
	OPCODE(b1)				/* LDA (ab),y */
	OPCODE(b3)				/* LAX (ab),y [unofficial] */
	OPCODE(b4)				/* LDY ab,x */
	OPCODE(b5)				/* LDA ab,x */
	OPCODE(b6)				/* LDX ab,y */
	OPCODE(b7)				/* LAX ab,y [unofficial] */
	OPCODE(b8)				/* CLV */
	OPCODE(b9)				/* LDA abcd,y */
	OPCODE(ba)				/* TSX */
	OPCODE(bb)				/* LAS abcd,y [unofficial - AND S with Mem, transfer to A and X (Fox) */
	OPCODE(bc)				/* LDY abcd,x */
	OPCODE(bd)				/* LDA abcd,x */
	OPCODE(be)				/* LDX abcd,y */
	OPCODE(bf)				/* LAX abcd,y [unofficial] */
	OPCODE(c0)				/* CPY #ab */
	OPCODE(c1)				/* CMP (ab,x) */
	OPCODE(c3)				/* DCM (ab,x) [unofficial - DEC Mem then CMP with Acc] */
	OPCODE(c4)				/* CPY ab */
	OPCODE(c5)				/* CMP ab */
	OPCODE(c6)				/* DEC ab */
	OPCODE(c7)				/* DCM ab [unofficial - DEC Mem then CMP with Acc] */
	OPCODE(c8)				/* INY */
	OPCODE(c9)				/* CMP #ab */
	OPCODE(ca)				/* DEX */
	OPCODE(cb)				/* SBX #ab [unofficial - store ((A AND X) - Mem) in X] (Fox) */
	OPCODE(cc)				/* CPY abcd */
	OPCODE(cd)				/* CMP abcd */
	OPCODE(ce)				/* DEC abcd */
	OPCODE(cf)				/* DCM abcd [unofficial - DEC Mem then CMP with Acc] */
	OPCODE(d0)				/* BNE */
	OPCODE(d1)				/* CMP (ab),y */
	OPCODE(d3)				/* DCM (ab),y [unofficial - DEC Mem then CMP with Acc] */
	OPCODE(d5)				/* CMP ab,x */
	OPCODE(d6)				/* DEC ab,x */
	OPCODE(d7)				/* DCM ab,x [unofficial - DEC Mem then CMP with Acc] */
	OPCODE(d8)				/* CLD */
	OPCODE(d9)				/* CMP abcd,y */
	OPCODE(db)				/* DCM abcd,y [unofficial - DEC Mem then CMP with Acc] */
	OPCODE(dd)				/* CMP abcd,x */
	OPCODE(de)				/* DEC abcd,x */
	OPCODE(df)				/* DCM abcd,x [unofficial - DEC Mem then CMP with Acc] */
	OPCODE(e0)				/* CPX #ab */
	OPCODE(e1)				/* SBC (ab,x) */
	OPCODE(e3)				/* INS (ab,x) [unofficial - INC Mem then SBC with Acc] */
	OPCODE(e4)				/* CPX ab */
	OPCODE(e5)				/* SBC ab */
	OPCODE(e6)				/* INC ab */
	OPCODE(e7)				/* INS ab [unofficial - INC Mem then SBC with Acc] */
	OPCODE(e8)				/* INX */

	OPCODE_ALIAS(e9)		/* SBC #ab */
	OPCODE(eb)				/* SBC #ab [unofficial] */

	OPCODE_ALIAS(ea)		/* NOP */
	OPCODE_ALIAS(1a)		/* NOP [unofficial] */
	OPCODE_ALIAS(3a)
	OPCODE_ALIAS(5a)
	OPCODE_ALIAS(7a)
	OPCODE_ALIAS(da)
	OPCODE(fa)

	OPCODE(ec)				/* CPX abcd */
	OPCODE(ed)				/* SBC abcd */
	OPCODE(ee)				/* INC abcd */
	OPCODE(ef)				/* INS abcd [unofficial - INC Mem then SBC with Acc] */
	OPCODE(f0)				/* BEQ */
	OPCODE(f1)				/* SBC (ab),y */
	OPCODE(f3)				/* INS (ab),y [unofficial - INC Mem then SBC with Acc] */
	OPCODE(f5)				/* SBC ab,x */
	OPCODE(f6)				/* INC ab,x */
	OPCODE(f7)				/* INS ab,x [unofficial - INC Mem then SBC with Acc] */
	OPCODE(f8)				/* SED */
	OPCODE(f9)				/* SBC abcd,y */
	OPCODE(fb)				/* INS abcd,y [unofficial - INC Mem then SBC with Acc] */
	OPCODE(fd)				/* SBC abcd,x */
	OPCODE(fe)				/* INC abcd,x */
	OPCODE(ff)				/* INS abcd,x [unofficial - INC Mem then SBC with Acc] */

	OPCODE_ALIAS(d2)
	OPCODE_ALIAS(f2)
	OPCODE(d2)				/* ESCRTS #ab (CIM) - on Atari is here instruction CIM [unofficial] !RS! */
	OPCODE(f2)				/* ESC #ab (CIM) - on Atari is here instruction CIM [unofficial] !RS! */
		/* OPCODE(ff: ESC #ab - opcode FF is now used for INS [unofficial] instruction !RS! */

	OPCODE_ALIAS(02)		/* CIM [unofficial - crash intermediate] */
	OPCODE_ALIAS(12)
	OPCODE_ALIAS(22)
	OPCODE_ALIAS(32)
	OPCODE_ALIAS(42)
	OPCODE_ALIAS(52)
	OPCODE_ALIAS(62)
	OPCODE_ALIAS(72)
	OPCODE_ALIAS(92)
	OPCODE(b2)

	The overflow flag is thus set when the most significant bit (here considered the sign bit) is changed by adding two numbers with the same sign (or subtracting two numbers with opposite signs). Overflow never occurs when the sign of two addition operands are different (or the sign of two subtraction operands are the same).
Internally, the overflow flag is usually generated by an exclusive or of the internal carry into and out of the sign bit. As the sign bit is the same as the most significant bit of a number considered unsigned, the overflow flag is "meaningless" and normally ignored when unsigned numbers are added or subtracted.
